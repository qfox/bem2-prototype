
bem-tools 2.0
=============

Общие мысли
-----------

Модульная штука, где ядро — это небольшая программа, использующая COA и для которой можно писать библиотеки.

Все, что относится к командам и АПИ реализуется в виде АПИ.

Уже сейчас с командами сделано так, что команды можно расширять. Это сделано за счет COA.

Текущее АПИ нужно выносить в отдельные модули.

Все команды реализуются в виде отдельных пакетов с экспортируемой функцией, которая на вход получает определенный контекст (?).

Но как писать эти команды? Копипастить код из текущих bem-tools плохо, т.к. будет много копипаста. Так что нужно вынести куда-то общебэмовую функциональность:

  * bem-config, который умеет читать common-js модуль. Когда программе нужна какая-то настройка, она дергает функцию из конфига (у нее зовется коллбек).
  * Уровни (bem-levels)
    * чтение конфигов
    * интроспеция
    * создание уровня
  * deps (bem-deps)
    * stub
    * parse
    * merge
    * intersect
    * substruct

Служебное низкоуровневое API (bem-util):

  * map
  * reduce
  * translate
  * create (new)

Build берет на вход декларацию (список) и технологию, а на выходе получается как правильно одна сущность — reduce (получает размеченный список сущности, у которых уже есть технология).

translate — это часть bem create, которая из одного файла технологии получает файл в новой технологии.

хочется писать технологии не для команд bem create/build, а технологии для сборки. Они будут работать по-разному в зависимости от необходимой собираемой технологии и вызывать внутри себя bem reduce, bem translate, etc.

bem-sets — это форк bem-pr, который отличается по интрефейсу, т.к. служебные библиотеки нужно подключать как npm-модули. Теперь bem-sets расширяются для сборки документации.

bem map — на входе несколько уровней и декларацию, а на выходе не одна сущность, а пачка значений. Пришедший набор в декларации возвращается таким же набором, но как-то трансформированным. Например, были common.blocks + desktop.blocks и в результате examples собираются смерженными по специальным правилам.

taffyDB

Тезисы
------

Структура проектов в общем смысле фиксирована (bundles/bundle/blocks/block, blocks/block, etc.), за исключением **/.bem.

Собираемые сущности: узел (бандл/блок), реализация технологии. Служебные сущности: уровень, технология. [понятия технологий несколько смешаны, говоря реализация я буду подразуменвать css, bemhtml, bemjson файлы самих блоков, говоря технология — уникальную алгоритмическую составляющую].

Любой проект — направленный граф из узлов и реализаций (далее граф проекта), описываемый в общем случае директорией узла и реализациями. Сборка любой цели работает с подграфом этого графа, получаемого путем несложного преобразования (map, filter, reduce, etc). Например, из графа проекта можно получить подграф для сборки реализации технологии X какого узла, граф из набора реализаций технологий [X,Y,Z], или граф блоков.

Filter может выполняться в любом порядке; map, reduce должны выполняться по упорядоченному подграфу относительно цели.

Граф проекта должен иметь возможность достраиваться асинхронно по требованию, чтобы не читать весь граф проекта при старте.

Модули предоставляют функционал через расширение базового объекта BEM (возможно, BEM.api), и может требовать какой-то функциональности. Таким образом, модули зависят друг от друга, но не напрямую (!) и работают через общий объект.

Модульная архитектура
---------------------

bem-tools — платформа для запуска модулей, работающих с bem предметной областью.
bem-config — Конфигурация — peer-dep: bem-tools — модуль, предоставляющий API для работы с конфигурациями уровней. Умеет читать любые конфиги, возможно, будет уметь мержить конфиги, но не вдаваясь в подробности самих конфгиов. Т.е. тупой extend.
bem-level — Уровень — peer-dep: bem-tools — хранит информацию об именовании и умеет получать плоские списки узлов, реализаций, технологий; предоставляет API для работы с информацией об уровнях.


